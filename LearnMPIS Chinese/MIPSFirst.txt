1. MPIS 的由来和发展
	Microprocessor without Interlocked Pipeline Stages  尽量利用软件办法避免流水线中的数据相关问题
	(Millions of Instructions Per Second）的双关语
	1981， 斯坦福大学教授Hennessy 领导团队
	
	CISC: x86 复杂指令集
	RISC: MIPS 精简指令集
	
	MIPS是八十年代中期RISC CPU 设计的一大热点
	很多领域， SONY， Nintendo 的游戏机， Cisco的路由器 和SGI超级计算机中使用
	
	通用处理器指令体系历经 MIPS I， MIPS II， MIPS III， MIPS IV， MIPS V 的发展；
	嵌入式指令体系历经 MIPS16， MIPS32 到MIPS64 的发展  已经非常成熟
	
	在设计理念上MIPS强调软硬件协同提高性能， 同时简化硬件设计
	
2. MIPS 的流水线结构， 特点
	五级流水：其实只有四个周期 （物理上）
		Fetch instruction （指令抓取）
		Read registers （寄存器的读取）
		Arithmetic operation （计算和具体执行）
		Memory access （访存）
		Write back （寄存器内容的写回）
		
	MIPS指令集的特点：（对比X86）
									MIPS32:						 	X86-32
		指令长度						固定（32位）						变长（1-15字节）		
									
									流水线的“取指”段（IF）时间固定
									
									常数字段小于32位（对于无条件跳转
									指令，立即数方式的目的地为26位
									其他指令的一般为16位）
		
		指令中的内存操作数				内存操作数无法直接参与运算			内存操作数可参与运算
		
									指令操作须适应流水线
									第四段才是访存	
		
		计算指令的操作数				多为3个							多为2个
									
									对编译优化有利
									

3. MIPS 指令集特点： （对比X86）
									MIPS32:						 	X86-32
				通用寄存器个数			32								8
									
									0号寄存器的value是0
									0是最有用的常数
									有利于节省指令编码
				
				条件码				无								有
									
									所有信息存于通用寄存器
									条件判断通过检验通用寄存器来进行
									
				访存操作				只能通过load/store 指令			多数指令支持
								
									支持双字，字，半字等；				无需地址对齐
									一般需要地址对齐		
									有专门的不对齐的指令		
									
									一种寻址方式：
									基址 + 常数偏移常量				多种
									
				半字字节运算			无 （软件解决）					有
				
				针对栈操作的支持		无								有专门指令
				
									一个通用寄存器习惯上作为栈顶地址寄存器
									（jal）
									
				过程调用指令			返回地址保存到31号寄存器			保存到栈
				
				其他					对于异常处理主要依赖于软件完成
				
				
4. Branch Delay Slot （跳转延迟）
		条件跳转指令的目标地址计算需要在ALU段获得，而此时的第二条指令已经进入流水线，存在一个延迟槽 (delay slot)
		需要程序员或者编译器优化来填充这个slot
		
5. Summary
	RISC 的设计思想在于简化计算机指令功能， 规格化指令设计，使得各个指令的流水线分段较为均匀，而且操作相对简单完整，从而提高主频
	
	采用load/store结构： 其他指令均在寄存器之间对数据进行处理，提高处理速度
	
	依赖软件（编译）实现优化及完成复杂功能
	
	E.g. 
		entrypoint:							# that's a label
			addu $1, $2, $3					# (registers) $s1	$2 + $3
			
		jal printf							# 调用过程
		move $4, $6							# 这条指令位于delay slot 内， 与前一条指令一起执行
		xxx									# return here after call 返回地址
		

6. 访存指令， 寄存器
	lw $1, offset($2)	任何寄存器都可以作为地址或者目标寄存器
			   offset	为16为的带符号数
			   
	寄存器
		使用32个通用寄存器
			0号寄存器永远value是0
			31号寄存器存放函数调用的地址
			其他的寄存器都是“一样的”
			没有指令寄存器
			
		整数乘除法的专用寄存器
			Hi ／ Lo
			
		32个浮点寄存器 （如果有浮点协处理器的话）
		
	MIPS32寄存器命名与使用惯例
		
		寄存器编号		名字			习惯用途
		0				zero		value永远是0
		1				at			保留给汇编器使用（编程时避免使用）
		2-3				v0，v1		过程调用返回值
		4-7				a0-a3		传参用寄存器
		8-15			t0-t7		调用者保存寄存器
		24-25			t8，t9		
		16-23			s0-s7		被调用者保存寄存器
		26，27			k0，k1		保留给异常处理使用
		28				gp			全局指针 （global pointer) 因为MIPS指令的立即数域宽有限， gp寄存器可以作为基址寄存器进行load/store寻址
		29				sp			栈顶指针
		30				fp			栈帧寄存器
		31				ra			保存过程调用的返回地址
		
7. 传统的MIPS32 传递过程参数的方式（不包括浮点数）
		使用寄存器传参（前四个）， 剩余使用栈
		E.G. thesame = trncmp ("bear", "bearer", 4)
			a0: address of "bear"
			a1: address of "bearer"
			a2: 4
			a3: undefined
			
8. 协处理器0 -- CP0
		支持虚拟储存，异常处理，运行状态切换等的系统控制协处理器
			从程序员的角度来看，就是一系列寄存器
				指令： MFC0， MTC0
				不能在用户态下访问
			与下列处理功能密切相关
				处理器运行模式，如大小端模式、当前运行状态等
				缓存控制
				异常／中断处理
				储存管理（MMU）
				其他
				
		CP0 寄存器部分汇总
		
		寄存器名称			编号						功能描述
		status				12						状态寄存器，包括处理器运行的状态、协处理器使能、某些中断使能以及一些处理器的配置信息
		Cause				13						什么原因导致的中断或者异常
		EPC					14						中断／异常处理完成之后从哪开始恢复运行
		Count				9						这一组寄存器形成了一个高分辨率定制器，频段一般是处理器频率的50%
		Compare				11
		BadVaddr			8						引起地址相关异常的指令／数据地址
		
		Context				4
		HentryHi			10						对MMU编程的寄存器
		EntryLo 0-1			10
		Index				0
		PageMask			5
		Random				1
		Wired				6
									
	
		